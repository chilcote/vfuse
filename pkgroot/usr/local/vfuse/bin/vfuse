#!/usr/bin/env python3
"""
This script takes a never-booted DMG and converts it to a VMware Fusion VM.
"""

##############################################################################
# Copyright 2016-Present Joseph Chilcote
#
#  Licensed under the Apache License, Version 2.0 (the "License"); you may not
#  use this file except in compliance with the License. You may obtain a copy
#  of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
#  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#  License for the specific language governing permissions and limitations
#  under the License.
##############################################################################

import argparse
import glob
import hashlib
import json
import logging
import os
import plistlib
import shutil
import ssl
import string
import subprocess
import sys
import tempfile
import threading
import time
from collections import OrderedDict
from pwd import getpwuid
from random import sample
from urllib.error import HTTPError
from urllib.request import urlretrieve


__version__ = "3.0.1"


class Error(Exception):
    """Class for domain specific exceptions."""


class VdiskManagerError(Error):
    """Gathers error from vmware-vdiskmanager."""


class Spinner:
    # ref: https://stackoverflow.com/a/39504463
    busy = False
    delay = 0.1

    @staticmethod
    def spinning_cursor():
        while 1:
            for cursor in "|/-\\":
                yield cursor

    def __init__(self, delay=None):
        self.spinner_generator = self.spinning_cursor()
        if delay and float(delay):
            self.delay = delay

    def spinner_task(self):
        while self.busy:
            sys.stdout.write(next(self.spinner_generator))
            sys.stdout.flush()
            time.sleep(self.delay)
            sys.stdout.write("\b")
            sys.stdout.flush()

    def start(self):
        self.busy = True
        threading.Thread(target=self.spinner_task).start()

    def stop(self):
        self.busy = False
        time.sleep(self.delay)


def colored(text, color=None):
    if not os.getenv("ANSI_COLORS_DISABLED"):
        fmt_str = "\033[%dm"
        reset = "\033[0m"
        colors = {
            "grey": 30,
            "gray": 30,
            "red": 31,
            "green": 32,
            "yellow": 33,
            "blue": 34,
            "magenta": 35,
            "cyan": 36,
            "white": 37,
        }
        if color is not None:
            text = fmt_str % (colors[color]) + text + reset
    return text


def import_template(template_name, current_dir, template_dir):
    """Imports user-defined template"""
    template = None
    if ".json" not in template_name:
        template_name += ".json"
    if os.path.exists(os.path.expanduser(template_name)):
        template = template_name
    else:
        for path in [template_dir, current_dir]:
            if os.path.exists(path):
                files = [
                    f for f in os.listdir(path) if os.path.isfile(os.path.join(path, f))
                ]
                for f in files:
                    if template_name == f:
                        template = os.path.join(path, f)
    if not template:
        print(colored("Unable to find template: %s" % template_name, "red"))
        exit(1)
    print(colored("Using template: %s" % template, "green"))
    try:
        with open(template) as f:
            try:
                d = json.load(f)
            except ValueError as err:
                print(
                    colored("Unable to parse %s\n" "Error: %s" % (template, err), "red")
                )
                sys.exit(1)
    except NameError as err:
        print(colored("%s; bailing script." % err, "red"))
        sys.exit(1)
    except IOError as err:
        print(colored("%s: %s" % (err.strerror, template), "red"))
        sys.exit(1)
    return d


def get_sha256(filename, block_size=65536):
    """Returns the sha256 of the filename"""
    if not os.path.exists(filename):
        return None
    sha256 = hashlib.sha256()
    print(colored("Generating checksum for %s" % os.path.basename(filename), "green"))
    spinner = Spinner()
    spinner.start()
    with open(filename, "rb") as f:
        for block in iter(lambda: f.read(block_size), b""):
            sha256.update(block)
    spinner.stop()
    return sha256.hexdigest()


def verify_checksum(i, checksum):
    if checksum:
        return True if i == checksum else False


def get_source_dmg(
    url,
    dmg,
    cache_dir,
    cache_receipt,
    checksum,
    template,
    source_dmg=None,
    downloaded=False,
    cached=False,
    cached_checksum=None,
    cached_dmg=None,
    generated_checksum=None,
):
    """Downloads Base OS DMG if URL defined by user
        Checks cache for existing Base OS image"""

    d = {}
    if os.path.exists(cache_receipt):
        with open(cache_receipt, "r") as f:
            d = json.load(f)
            cached_dmg = d.get(template, None)
            if cached_dmg and cached_dmg != dmg:
                print(
                    colored("Deleting previously cached dmg: %s" % cached_dmg, "green")
                )
                if os.path.exists(os.path.join(cache_dir, cached_dmg)):
                    os.remove(os.path.join(cache_dir, cached_dmg))
            cached_checksum = d.get(dmg, None)

        if os.path.exists(os.path.join(cache_dir, dmg)):
            if checksum and verify_checksum(cached_checksum, checksum):
                print(colored("%s exists in cache" % dmg, "green"))
                source_dmg = os.path.join(cache_dir, dmg)
                generated_checksum = cached_checksum
                cached = True
            else:
                print(colored("Deleting previously cached dmg: %s" % dmg, "green"))
                if os.path.exists(os.path.join(cache_dir, dmg)):
                    os.remove(os.path.join(cache_dir, dmg))

    if not cached:
        print(colored("Downloading %s" % url, "green"))
        downloaded = True
        spinner = Spinner()
        spinner.start()
        try:
            # allow downloading from apache server with self-signed cert
            ssl._create_default_https_context = ssl._create_unverified_context
            source_dmg, _ = urlretrieve(url, os.path.join(tempfile.mkdtemp(), dmg))
        except HTTPError as e:
            print(colored("Download of %s failed with error %s" % (url, e), "red"))
            spinner.stop()
            sys.exit(1)
        except IOError as e:
            source_dmg = source_dmg if source_dmg else "remote DMG"
            print(colored("Could not write %s to disk. Failed with error: %s" % (source_dmg, e), "red"))
            if "urlopen error" in str(e):
                print(colored("Make sure remote host is accessible: %s" % url, "red"))
            spinner.stop()
            sys.exit(1)
        spinner.stop()

        if os.path.exists(source_dmg):
            generated_checksum = get_sha256(source_dmg)
            if not (
                verify_checksum(generated_checksum, checksum) if checksum else True
            ):
                print(colored("Checksum mismatch!", "red"))
                print(colored("Downloaded DMG: %s" % generated_checksum, "red"))
                print(colored("Checksum from template: %s" % checksum, "red"))
                os.remove(source_dmg)
                spinner.stop()
                sys.exit(1)

    d[template] = os.path.basename(source_dmg)
    d[os.path.basename(source_dmg)] = generated_checksum

    return source_dmg, downloaded, cached, generated_checksum, d


def mount_dmg(dmg, disk_id=False):
    """Mounts base DMG"""
    d = {}
    if not dmg:
        print(colored("No source DMG provided", "red"))
        sys.exit(1)
    print(colored("Mounting %s" % dmg, "green"))
    try:
        output = subprocess.check_output(
            [
                "/usr/bin/hdiutil",
                "attach",
                "-nobrowse",
                "-noverify",
                "-noautoopen",
                dmg,
                "-plist",
            ]
        )
        d = plistlib.loads(output)
        ignored_vols = ("preboot", "recovery", "vm", "data")
        for i in d["system-entities"]:
            if i.get("mount-point", None):
                if not any(x in i["mount-point"].split("/")[-1].lower() for x in ignored_vols):
                    mount_point = i["mount-point"]
                    volume_kind = i["volume-kind"]
                    mountpoint_dev_entry = i["dev-entry"]
            if i["content-hint"] == "GUID_partition_scheme":
                disk_id = i["dev-entry"]
        if not disk_id:
            print(
                colored(
                    "Warning: your DMG does not have a partition "
                    "scheme, and vfuse may fail",
                    "yellow",
                )
            )
            disk_id = mountpoint_dev_entry
        return mount_point, disk_id, volume_kind
    except subprocess.CalledProcessError:
        print(colored("Cannot mount dmg: %s" % dmg, "red"))
        sys.exit(1)


def get_osvers(mount_point):
    """Returns the OS Version of the mounted system DMG"""
    sysvers_plist = os.path.join(
        mount_point, "System/Library/CoreServices/SystemVersion.plist"
    )
    try:
        with open(sysvers_plist, "rb") as f:
            d = plistlib.load(f)
        return d["ProductVersion"]
    except IOError as err:
        print(colored(str(err), "red"))
        unmount_dmg(mount_point)
        sys.exit(1)


def unmount_dmg(pathname):
    """Unmounts a DMG"""
    if os.path.exists(pathname):
        print(colored("Unmounting %s" % pathname, "green"))
        task = subprocess.Popen(
            ["/usr/bin/hdiutil", "detach", "-force", pathname],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
        )
        out, err = task.communicate()
        if err:
            print(colored("Could not detach:\t%s" % pathname, "yellow"))


def unmount_vols(disk_id):
    """Unmount all volumes at the disk_id"""
    print(colored("Unmounting %s" % disk_id, "green"))
    task = subprocess.Popen(
        ["/usr/sbin/diskutil", "unmountDisk", disk_id],
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
    )
    out, err = task.communicate()
    if err:
        print(colored("Could not unmount:\t%s" % disk_id, "yellow"))


def create_vmdk(
    output_dir,
    output_name,
    disk_id,
    disk_type,
    fusion_path,
    use_qemu,
    qemu_path,
    source_dmg,
):
    """Converts Base OS DMG to VMDK"""

    cmd = ["/usr/bin/mdfind", "kMDItemCFBundleIdentifier == com.vmware.fusion"]
    fusion_path = sorted(subprocess.check_output(cmd).strip().split(b"\n"))[0]

    if not fusion_path:
        try:
            fusion_path = glob.glob("/Applications/VMware Fusion*.app")[0]
        except IndexError:
            print(colored("Error: VMware Fusion.app not found", "red"))
            unmount_dmg(disk_id)
            sys.exit(1)

        cmd = ["/usr/bin/mdfind", "kMDItemCFBundleIdentifier == com.vmware.fusion"]
        fusion_path = sorted(subprocess.check_output(cmd).strip().split(b"\n"))[0]

        if not fusion_path:
            try:
                fusion_path = glob.glob("/Applications/VMware Fusion*.app")[0]
            except IndexError:
                print(colored("Error: VMware Fusion.app not found", "red"))
                unmount_dmg(disk_id)
                sys.exit(1)

    fusion_tools_path = os.path.join(fusion_path, b"Contents/Library")

    vmpath = os.path.join(output_dir, output_name + ".vmwarevm")
    if os.path.exists(vmpath):
        print(colored("VMware Fusion VM already exists: %s" % vmpath, "red"))
        sys.exit(1)
    os.mkdir(vmpath)

    vmdk = os.path.join(vmpath, output_name + ".vmdk")

    if use_qemu:
        cmd = [qemu_path, "convert", "-O", "vmdk", source_dmg, vmdk]
        print(colored("Using qemu-img path: %s" % qemu_path, "green"))
        print(colored("Converting DMG to VMDK", "green"))
        spinner = Spinner()
        spinner.start()
        try:
            task = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            out, err = task.communicate()
            if err:
                print(colored("Error: %s" % err.strip(), "red"))
                print(
                    colored(
                        "There is a problem with your DMG, " "please try again", "red"
                    )
                )
                spinner.stop()
                sys.exit(1)
        except OSError as e:
            err = "Failed to execute %s: %s" % (cmd[0], e)
            print(colored("Error: %s" % err, "red"))
            shutil.rmtree(vmpath)
            spinner.stop()
            sys.exit(1)
        spinner.stop()
    else:
        cmd = ["/usr/bin/pgrep", "-f", fusion_path + b"/Contents/MacOS/VMware Fusion"]
        task = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        out, err = task.communicate()
        if task.returncode:
            print(colored("Error: VMware Fusion.app is not running", "red"))
            shutil.rmtree(vmpath)
            sys.exit(1)

        print(
            colored(
                "Using VMware Fusion path: %s" % fusion_path.decode("utf-8"), "green"
            )
        )
        link = os.path.join(vmpath, os.path.basename(disk_id) + "-link")

        print(colored("Converting DMG to VMDK", "green"))
        spinner = Spinner()
        spinner.start()
        try:
            # /Applications/VMware\ Fusion.app/Contents/Library/\
            # vmware-rawdiskCreator create /dev/disk2 \
            # fullDevice ./disk2-link lsilogic
            cmd = [
                os.path.join(fusion_tools_path, b"vmware-rawdiskCreator"),
                "create",
                disk_id,
                "fullDevice",
                link,
                "lsilogic",
            ]
            task = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            out, err = task.communicate()
            if err:
                print(colored("Error: %s" % err.strip(), "red"))
                print(
                    colored(
                        "There is a problem with your DMG; "
                        "please re-create it and try again",
                        "red",
                    )
                )
                spinner.stop()
                unmount_dmg(disk_id)
                sys.exit(1)

            # /Applications/VMware\ Fusion.app/Contents/Library/\
            # vmware-vdiskmanager -r ./disk2-link.vmdk -t 0 ./macos-disk.vmdk
            cmd = [
                os.path.join(fusion_tools_path, b"vmware-vdiskmanager"),
                "-r",
                link + ".vmdk",
                "-t",
                str(disk_type),
                vmdk,
            ]
            task = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            out, err = task.communicate()
            if task.returncode:
                if not err:
                    err = "Undetermined error with vmware-vdiskmanager"
                raise VdiskManagerError(err.strip())

        except OSError as e:
            err = "Failed to execute %s: %s" % (cmd[0], e)
            print(colored("Error: %s" % err, "red"))
            unmount_dmg(disk_id)
            shutil.rmtree(vmpath)
            spinner.stop()
            sys.exit(1)

        except VdiskManagerError as e:
            print(colored("Error: %s" % e, "red"))
            unmount_dmg(disk_id)
            shutil.rmtree(vmpath)
            spinner.stop()
            sys.exit(1)

        spinner.stop()
        os.remove(link + ".vmdk")

        print(colored("Hiding file extension", "green"))
        try:
            cmd = ["/usr/bin/SetFile", "-a", "E", vmpath]
            task = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            out, err = task.communicate()
        except err:
            print(colored("Error: %s" % err.strip(), "red"))

    return vmpath, fusion_tools_path


def set_perms(path):
    """Sets the permissions of given path to local user"""
    uid = getpwuid(os.stat("/dev/console").st_uid).pw_uid
    os.chown(path, int(uid), 20)
    for _, _, files in os.walk(path):
        for f in files:
            os.chown(os.path.join(path, f), int(uid), 20)


def create_vmx(
    vmpath,
    output_name,
    guest_os,
    hw_version,
    mem_size,
    connection_type,
    enable3d,
    vnc_port,
    vnc_passwd,
    mac_address,
    hw_model,
    board_id,
    serial_number,
    serial_format,
    shared_folder,
    dvdiso,
    recovery,
):
    """Generates a working VMX file"""
    vmx = os.path.join(vmpath, output_name + ".vmx")
    print(colored("Populating VMX file", "green"))
    with open(vmx, "w") as f:
        f.write('.encoding = "UTF-8"\n')
        f.write('config.version = "8"\n')
        f.write('virtualhw.version = "%d"\n' % hw_version)
        f.write('numvcpus = "2"\n')
        f.write('sata0.present = "TRUE"\n')
        f.write('memsize = "%d"\n' % mem_size)
        f.write('sata0:0.present = "TRUE"\n')
        f.write('sata0:0.fileName = "%s.vmdk"\n' % output_name)
        f.write('sata0:1.present = "TRUE"\n')
        f.write('sata0:1.autodetect = "TRUE"\n')
        f.write('sata0:1.deviceType = "cdrom-raw"\n')
        f.write('sata0:1.startConnected = "FALSE"\n')
        f.write('ethernet0.present = "TRUE"\n')
        f.write('ethernet0.connectionType = "%s"\n' % connection_type)
        f.write('ethernet0.virtualDev = "e1000e"\n')
        f.write('ethernet0.wakeOnPcktRcv = "FALSE"\n')
        f.write('ethernet0.linkStatePropagation.enable = "TRUE"\n')
        f.write('usb.present = "TRUE"\n')
        f.write('ehci.present = "TRUE"\n')
        f.write('ehci.pciSlotNumber = "0"\n')
        f.write('pciBridge0.present = "TRUE"\n')
        f.write('pciBridge4.present = "TRUE"\n')
        f.write('pciBridge4.virtualDev = "pcieRootPort"\n')
        f.write('pciBridge4.functions = "8"\n')
        f.write('pciBridge5.present = "TRUE"\n')
        f.write('pciBridge5.virtualDev = "pcieRootPort"\n')
        f.write('pciBridge5.functions = "8"\n')
        f.write('pciBridge6.present = "TRUE"\n')
        f.write('pciBridge6.virtualDev = "pcieRootPort"\n')
        f.write('pciBridge6.functions = "8"\n')
        f.write('pciBridge7.present = "TRUE"\n')
        f.write('pciBridge7.virtualDev = "pcieRootPort"\n')
        f.write('pciBridge7.functions = "8"\n')
        f.write('vmci0.present = "TRUE"\n')
        f.write('smc.present = "TRUE"\n')
        f.write('hpet0.present = "TRUE"\n')
        f.write('ich7m.present = "TRUE"\n')
        f.write('firmware = "efi"\n')
        f.write('displayname = "%s"\n' % output_name)
        f.write('guestos = "%s"\n' % guest_os)
        f.write('nvram = "%s.nvram"\n' % output_name)
        f.write('keyboardAndMouseProfile = "macProfile"\n')
        f.write('floppy0.present = "FALSE"\n')
        f.write('msg.autoanswer = "TRUE"\n')
        f.write('tools.syncTime = "TRUE"\n')
        f.write('board-id.reflectHost = "FALSE"')
        if enable3d:
            f.write('\nmks.enable3d = "TRUE"')
        else:
            f.write('\nmks.enable3d = "FALSE"')
        if vnc_passwd:
            f.write('\nremotedisplay.vnc.enabled = "TRUE"\n')
            f.write('remotedisplay.vnc.port = "%s"\n' % vnc_port)
            f.write('RemoteDisplay.vnc.key = "%s"' % vnc_passwd)
        if mac_address:
            f.write('\nethernet0.addressType = "static"\n')
            f.write('ethernet0.address = "%s"' % mac_address)
        else:
            f.write('\nethernet0.addressType = "generated"')
        if hw_model:
            f.write('\nhw.model = "%s"' % hw_model)
            f.write('\nhw.model.reflectHost = "FALSE"')
            f.write('\nsmbios.reflectHost = "FALSE"')
        if board_id:
            f.write('\nboard-id = "%s"' % board_id)
        if serial_number:
            f.write('\nserialNumber = "%s"' % serial_number)
            f.write('\nserialNumber.reflectHost = "FALSE"')
        if serial_format:
            f.write('\nSMBIOS.use12CharSerialNumber = "TRUE"')
        if shared_folder:
            f.write('\nsharedFolder0.present = "true"\n')
            f.write('sharedFolder0.enabled = "true"\n')
            f.write('sharedFolder0.readAccess = "true"\n')
            f.write('sharedFolder0.writeAccess = "true"\n')
            f.write('sharedFolder0.hostPath = "%s"\n' % shared_folder)
            f.write('sharedFolder0.guestName = "-vfuse"\n')
            f.write('sharedFolder0.expiration = "never"\n')
            f.write('sharedfolder.maxnum = "1"\n')
            f.write('hgfs.mapRootShare = "TRUE"\n')
            f.write('hgfs.linkRootShare = "TRUE"\n')
            f.write('isolation.tools.hgfs.disable = "FALSE"')
        if dvdiso:
            f.write('\nsata0:2.present = "TRUE"\n')
            f.write('sata0:2.autodetect = "TRUE"\n')
            f.write('sata0:2.deviceType = "cdrom-image"\n')
            f.write('sata0:2.fileName = "%s"' % dvdiso)
        if recovery:
            f.write('\nmacosguest.forceRecoveryModeInstall = "TRUE"')
    return vmx


def generic_packer_template():
    """Returns a baseline packer template"""
    d = {
        "builders": [
            {
                "type": "vmware-vmx",
                "source_path": "",
                "ssh_username": "vagrant",
                "ssh_password": "vagrant",
                "ssh_port": "22",
                "ssh_wait_timeout": "10000s",
                "tools_upload_flavor": "darwin",
                "shutdown_command": "sudo shutdown -h now",
            }
        ],
        "min_packer_version": "0.8.6",
        "post-processors": ["vagrant"],
    }
    return OrderedDict(d)


def populate_packer_template(path, template, os_rev):
    """Creates a packer template file"""
    if not os.path.exists(template):
        print(colored("File not found; creating generic one: %s" % template, "yellow"))
        d = generic_packer_template()
    else:
        with open(template, "r") as f:
            d = json.load(f, object_pairs_hook=OrderedDict)
    d["builders"][0]["source_path"] = path
    # handle alternate darwin iso used as of VMware Fusion 8.5.4, for
    # pre-10.11 guests
    if os_rev < 11:
        d["builders"][0]["tools_upload_flavor"] = "darwinPre15"
    with open(template, "w") as f:
        json.dump(d, f, indent=4, separators=(",", ": "))
    set_perms(template)


def create_empty_dmg(size, netboot_tmp_dir=None):
    """Create an empty dmg to be used in a netboot scenario"""
    if not netboot_tmp_dir:
        netboot_tmp_dir = tempfile.mkdtemp()
    else:
        netboot_tmp_dir = os.path.expanduser(netboot_tmp_dir)
        if not os.path.exists(netboot_tmp_dir):
            os.mkdir(netboot_tmp_dir)
    temp_dmg = os.path.join(os.path.expanduser(netboot_tmp_dir), "vfuse_tmp.dmg")
    converted_dmg = os.path.join(tempfile.mkdtemp(), "vfuse_converted.dmg")

    print(colored("Creating temporary DMG: %s" % temp_dmg, "green"))
    spinner = Spinner()
    spinner.start()
    cmd = [
        "/usr/bin/hdiutil",
        "create",
        os.path.splitext(os.path.expanduser(temp_dmg))[0],
        "-size",
        size + "g",
        "-volname",
        "Macintosh HD",
        "-layout",
        "GPTSPUD",
        "-fs",
        "JHFS+",
        "-mode",
        "775",
        "-uid",
        "0",
        "-gid",
        "80",
    ]
    task = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out, err = task.communicate()
    if err:
        print(colored(err, "red"))
        spinner.stop()
        exit(1)
    spinner.stop()

    if os.path.exists(temp_dmg):
        print(colored("Converting temporary DMG: %s" % converted_dmg, "green"))
        spinner.start()
        cmd = [
            "/usr/bin/hdiutil",
            "convert",
            temp_dmg,
            "-format",
            "UDZO",
            "-o",
            converted_dmg,
        ]
        task = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        out, err = task.communicate()
        if err:
            print(colored("Could not convert empty dmg", err))
            shutil.rmtree(os.path.dirname(temp_dmg))
            spinner.stop()
            exit(1)
        spinner.stop()
    shutil.rmtree(os.path.dirname(temp_dmg))
    return converted_dmg


def main():
    """Main method"""
    parser = argparse.ArgumentParser(description="Create VM from source DMG.")
    parser.add_argument(
        "--version", action="store_true", help="show the version number"
    )
    parser.add_argument("-i", "--input", help="/path/to/dmg")
    parser.add_argument("-o", "--output", help="/path/to/output/dir")
    parser.add_argument("-n", "--name", help="Use a custom name")
    parser.add_argument("-w", "--hw-version", help="VMware hardware version", type=int)
    parser.add_argument("-m", "--mem-size", help="Memory Size in MB", type=int)
    parser.add_argument(
        "-s",
        "--serial",
        help="Custom Serial number",
        nargs="?",
        const="random",
        default=None,
    )
    parser.add_argument("-t", "--template", help="Use a template")
    parser.add_argument(
        "-e", "--esx", help="Create pre-allocated ESX-type VMDK", action="store_true"
    )
    parser.add_argument("--disk_type", help="Set the VMDK options", type=int)
    parser.add_argument("-p", "--packer", help="Populate a packer template")
    parser.add_argument("-d", help="Path to CD/DVD ISO path ", default=None)
    parser.add_argument("--hw-model", help="Custom hardware model", default=None)
    parser.add_argument("--board-id", help="Custom hardware board id", default=None)
    parser.add_argument(
        "--use-qemu",
        help="Use qemu-img intead of the Fusion CLI tools [/path/to/qemu-img]",
        default=False,
        const="/usr/local/bin/qemu-img",
        nargs="?",
        action="store",
    )
    parser.add_argument("--recovery", help="Boot into Recovery HD", action="store_true")
    parser.add_argument(
        "--snapshot", help="Create initial snapshot", action="store_true"
    )
    parser.add_argument("--snapshot-name", help="Custom name for the initial snapshot")
    parser.add_argument("-c", "--checksum", help="Generate checksum of a DMG")
    parser.add_argument(
        "--list-templates",
        help="Return list of available templates",
        action="store_true",
    )
    parser.add_argument(
        "--list-cache", help="Return list of cached disk images", action="store_true"
    )
    parser.add_argument(
        "--clear-cache", help="Clear cached disk images", action="store_true"
    )
    args = parser.parse_args()

    if args.version:
        print(__version__)
        exit(0)

    if (
        os.getuid() != 0
        and not args.use_qemu
        and not args.list_templates
        and not args.list_cache
        and not args.clear_cache
    ):
        print(
            colored(
                "If you don't want to be prompted in the GUI for "
                "an admin password, run this script with "
                "sudo rights\n",
                "yellow",
            )
        )

    # Instantiate variables
    fusion_path = ""
    source_dmg = ""
    output_dir = os.getcwd()
    output_name = "macos-vm"
    cached = False
    cache_dir = os.path.join(os.getenv("HOME"), ".vfuse")
    cache_receipt = os.path.join(cache_dir, "cache.receipt")
    updated_cache = {}
    checksum = None
    hw_version = 16
    mem_size = 4096
    disk_type = 0
    dvdiso = None
    connection_type = "nat"
    mac_address = None
    enable3d = False
    vnc_port = None
    vnc_passwd = None
    hw_model = None
    board_id = None
    serial_number = None
    shared_folder = None
    packer_template = False
    use_qemu = False
    qemu_path = "/usr/local/bin/qemu-img"
    netboot = False
    netboot_hdsize = "40"
    netboot_osvers = get_osvers("/")
    netboot_tmp_dir = None
    recovery = False
    snapshot = False
    snapshot_name = "baseline"
    downloaded = False
    serial_format = False
    dmg_name = ""
    guest_os = ""
    logger_file = None

    template_dir = ""
    config_file = os.path.join(
        os.path.dirname(os.path.realpath(sys.argv[0])), "config.json"
    )
    if os.path.exists(config_file):
        try:
            with open(config_file) as f:
                config = json.load(f)
                template_dir = config.get("template_dir", template_dir)
        except FileNotFoundError:
            pass

    if args.list_templates:
        templates = []
        for path in [output_dir, template_dir]:
            if os.path.exists(path):
                files = [
                    f for f in os.listdir(path) if os.path.isfile(os.path.join(path, f))
                ]
                for f in files:
                    if f.lower().endswith(".json"):
                        templates.append(f)
        print("\n".join(sorted(set(templates))))
        sys.exit(0)

    if args.list_cache:
        cached_dmgs = []
        if os.path.exists(cache_dir):
            files = [
                f
                for f in os.listdir(cache_dir)
                if os.path.isfile(os.path.join(cache_dir, f))
            ]
            for f in files:
                if f.lower().endswith(".dmg"):
                    cached_dmgs.append(f)
        if cached_dmgs:
            print("\n".join(sorted(set(cached_dmgs))))
        else:
            print(colored("No cached disk images found.", "green"))
        sys.exit(0)

    if args.clear_cache:
        if os.path.exists(cache_dir):
            files = [
                f
                for f in os.listdir(cache_dir)
                if os.path.isfile(os.path.join(cache_dir, f))
            ]
            for f in files:
                if f.lower().endswith(".dmg"):
                    print(colored("Removing %s" % f, "yellow"))
                    os.remove(os.path.join(cache_dir, f))
        with open(cache_receipt, "w") as f:
            json.dump({}, f, indent=4, separators=(",", ": "))
        if os.getuid() == 0:
            set_perms(cache_receipt)
        sys.exit(0)

    if (
        not args.input
        and not args.template
        and not args.start
        and not args.stop
        and not args.reset
        and not args.checksum
    ):
        parser.print_help()
        sys.exit(1)

    if args.input:
        source_dmg = os.path.expanduser(args.input)

    if args.output:
        output_dir = os.path.expanduser(args.output)

    if args.name:
        output_name = args.name

    if args.hw_model:
        hw_model = args.hw_model

    if args.board_id:
        board_id = args.board_id

    if args.d:
        dvdiso = args.d

    if args.hw_version:
        hw_version = args.hw_version

    if args.mem_size:
        mem_size = args.mem_size

    if args.serial == "random":
        s = string.ascii_lowercase + string.digits
        serial_number = "VM" + "".join(sample(s, 10))
    else:
        serial_number = args.serial

    if args.esx:
        disk_type = 4

    if args.disk_type:
        disk_type = args.disk_type

    if args.packer:
        packer_template = args.packer

    if args.use_qemu:
        use_qemu = True
        if os.path.exists(args.use_qemu):
            qemu_path = args.use_qemu

    if args.recovery:
        recovery = True

    if args.snapshot:
        snapshot = True

    if args.snapshot_name:
        snapshot_name = args.snapshot_name

    if args.checksum:
        source_dmg = os.path.expanduser(args.checksum)
        checksum = get_sha256(source_dmg)
        print(colored("Checksum: %s" % checksum, "green"))
        sys.exit(0)

    if args.template:
        # Use template-defined keys, otherwise use defaults defined above.
        d = import_template(args.template, output_dir, template_dir)
        if d.get("fusion_path"):
            fusion_path = os.path.expanduser(d["fusion_path"])
            if not os.path.exists(fusion_path):
                print(colored("VMware Fusion not found at %s" % fusion_path, "red"))
                sys.exit(1)
        if not d.get("source_dmg") and not d.get("netboot") and not source_dmg:
            parser.print_help()
            sys.exit(1)
        if d.get("netboot"):
            netboot = d["netboot"]
            if d.get("netboot_hdsize"):
                netboot_hdsize = str(d["netboot_hdsize"])
            if d.get("netboot_osvers"):
                netboot_osvers = d["netboot_osvers"]
            if d.get("netboot_tmp_dir"):
                netboot_tmp_dir = d["netboot_tmp_dir"]
            source_dmg = create_empty_dmg(netboot_hdsize, netboot_tmp_dir)
            connection_type = "bridged"
        elif d.get("source_dmg"):
            source_dmg = os.path.expanduser(d["source_dmg"])

        if d.get("checksum"):
            checksum = d["checksum"]
        if d.get("output_dir"):
            output_dir = os.path.expanduser(d["output_dir"])
        if d.get("output_name"):
            output_name = d["output_name"]

        output_vmpath = os.path.join(output_dir, output_name + ".vmwarevm")
        if os.path.exists(output_vmpath):
            print(colored("VMware Fusion VM already exists: %s" % output_vmpath, "red"))
            sys.exit(1)

        if d.get("cache"):
            cached = d["cache"]
            if "http" in source_dmg and cached:
                if not os.path.exists(cache_dir):
                    os.mkdir(cache_dir)
                dmg_name = os.path.basename(source_dmg)
                template_name = args.template.split(".")[0]
                (
                    source_dmg,
                    downloaded,
                    cached,
                    generated_checksum,
                    updated_cache,
                ) = get_source_dmg(
                    source_dmg,
                    dmg_name,
                    cache_dir,
                    cache_receipt,
                    checksum,
                    template_name,
                )
        if d.get("hw_version"):
            hw_version = int(d["hw_version"])
        if d.get("mem_size"):
            mem_size = int(d["mem_size"])
        if d.get("disk_type"):
            disk_type = int(d["disk_type"])
        if d.get("packer_template"):
            packer_template = d["packer_template"]
        if d.get("bridged"):
            connection_type = "bridged"
        if d.get("mac_address"):
            mac_address = d["mac_address"]
        if d.get("enable3d"):
            enable3d = True
        if d.get("vnc_port"):
            vnc_port = int(d["vnc_port"])
        if d.get("vnc_passwd"):
            vnc_passwd = d["vnc_passwd"]
        if d.get("hw_model"):
            hw_model = d["hw_model"]
        if d.get("board_id"):
            board_id = d["board_id"]
        if d.get("serial_number"):
            serial_number = d["serial_number"]
            if serial_number == "random":
                s = string.ascii_lowercase + string.digits
                serial_number = "VM" + "".join(sample(s, 10))
        if d.get("shared_folder"):
            shared_folder = os.path.expanduser(d["shared_folder"])
        if d.get("use_qemu"):
            use_qemu = d["use_qemu"]
        if d.get("qemu_path"):
            qemu_path = d["qemu_path"]
        if d.get("recovery"):
            recovery = d["recovery"]
        if d.get("snapshot"):
            snapshot = d["snapshot"]
        if d.get("snapshot_name"):
            snapshot_name = d["snapshot_name"]
        if d.get("logger_file"):
            logger_file = d["logger_file"]

    mount_point, disk_id, volume_kind = mount_dmg(source_dmg)

    os_vers = get_osvers(mount_point) if not netboot else netboot_osvers
    print(colored("macOS version is %s" % os_vers, "green"))
    os_rev = int(os_vers.split(".")[1])
    if os_rev <= 8:
        serial_format = True
    if (os_rev < 7) or (os_rev > 15):
        print(colored("This macOS version is not supported: %s" % os_vers, "red"))
        unmount_dmg(mount_point)
        sys.exit(1)
    # 10.7 (darwin11-64) requires virtualHW.version 8
    # 10.8 (darwin12-64) requires virtualHW.version 9
    # 10.9 (darwin13-64) requires virtualHW.version 10
    # 10.10 (darwin14-64) requires virtualHW.version 11
    # 10.11 (darwin15-64) requires virtualHW.version 12
    # 10.12 (darwin16-64) requires virtualHW.version 12 # What?? Apparently so.
    # 10.13 (darwin17-64) requires virtualHW.version 14
    # 10.14 (darwin18-64) requires virtualHW.version 16 # yer killing me, VMware
    # 10.15 (darwin19-64) requires virtualHW.version 16 # well ok, then
    if os_rev == 12:
        hw_check = os_rev
    elif os_rev == 14:
        hw_check = os_rev + 2
    else:
        hw_check = os_rev + 1

    if hw_check > hw_version:
        print(
            colored(
                "VMware hardware version %d does not officially "
                "support 10.%d" % (hw_version, os_rev),
                "yellow",
            )
        )

    # Temporarily drops the guest_os down by one
    # Uncomment these lines during macOS beta season
    # if os_rev >= 15:
    #     os_rev = os_rev - 1
    guest_os = "darwin%d-64" % (os_rev + 4)

    if volume_kind == "apfs":
        unmount_vols(disk_id)

    vmpath, fusion_tools_path = create_vmdk(
        output_dir,
        output_name,
        disk_id,
        disk_type,
        fusion_path,
        use_qemu,
        qemu_path,
        source_dmg,
    )

    vmx = create_vmx(
        vmpath,
        output_name,
        guest_os,
        hw_version,
        mem_size,
        connection_type,
        enable3d,
        vnc_port,
        vnc_passwd,
        mac_address,
        hw_model,
        board_id,
        serial_number,
        serial_format,
        shared_folder,
        dvdiso,
        recovery,
    )
    unmount_dmg(disk_id)

    if snapshot:
        print(colored('Creating a "%s" snapshot' % snapshot_name, "green"))
        cmd = [
            os.path.join(fusion_tools_path, b"vmrun"),
            "-T",
            "fusion",
            "snapshot",
            vmx,
            snapshot_name,
        ]
        task = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        out, err = task.communicate()
        if err:
            print(colored("Error: %s" % err.strip(), "yellow"))
            print(colored("There is a problem creating a snapshot", "yellow"))

    if os.getuid() == 0:
        set_perms(vmpath)

    if packer_template:
        print(colored("Generating packer template: %s" % packer_template, "green"))
        populate_packer_template(vmpath, packer_template, os_rev)

    print(colored("VMware Fusion VM created at %s" % vmpath, "green"))

    if netboot:
        if os.path.exists(source_dmg) and "tmp" in source_dmg:
            shutil.rmtree(os.path.dirname(source_dmg))

    if downloaded:
        print(colored("Caching %s" % dmg_name, "green"))
        print(colored("Checksum: %s" % generated_checksum, "green"))
        if os.path.exists(os.path.join(cache_dir, os.path.basename(source_dmg))):
            os.remove(os.path.join(cache_dir, os.path.basename(source_dmg)))
        shutil.move(source_dmg, cache_dir)
        if os.getuid() == 0:
            set_perms(cache_dir)

    if updated_cache:
        print(colored("Updating %s" % cache_receipt, "green"))
        with open(cache_receipt, "w") as f:
            json.dump(updated_cache, f, indent=4, separators=(",", ": "))
        if os.getuid() == 0:
            set_perms(cache_receipt)

    if logger_file:
        msg_type = "vfuse"
        action = "build"
        status = "success"
        message = args.template.split("/")[-1].replace(".json", "")

        try:
            root_logger = logging.getLogger()
            mylogger = logging.getLogger("vfuse_logger")
            mylogger.setLevel(logging.INFO)
            our_formatter = logging.Formatter(
                fmt="%(asctime)s; %(message)s", datefmt="%Y-%m-%d %H:%M:%S %z"
            )
            # Set up file handler
            file_handler = logging.FileHandler(logger_file)
            file_handler.setLevel(logging.INFO)
            file_handler.setFormatter(our_formatter)
            mylogger.addHandler(file_handler)
            root_logger.disabled = True
            # Message must always match a certain structure
            msg = "type: {}; action: {}; status: {}; msg: {};".format(
                msg_type, action, status, message
            )
            mylogger.info(msg)
        except IOError:
            print(colored("Use sudo to write to logger: %s" % logger_file, "yellow"))


if __name__ == "__main__":
    main()
